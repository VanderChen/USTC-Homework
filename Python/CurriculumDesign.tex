%!TEX program = pdflatex
\documentclass[UTF8]{article}

\usepackage[UTF8]{ctex}
% \usepackage{minted}
\usepackage{listings}
\usepackage{color}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}

\title{Python 课程设计}
\author{xxx}
\date{}
\begin{document}
\maketitle

\section{背景介绍}
本次课程设计为
\section{数据采集}
\subsection{系统结构}


\subsection{代码部分}
\begin{lstlisting}[language=Python, caption=server.py]
def butter_lowpass(data, pass_freq, stop_freq, Rp = 3, Rs = 30, fs = 1000):
    Wp = pass_freq / (fs / 2)
    Ws = stop_freq / (fs / 2)

    N, Wn = signal.buttord(Wp, Ws, Rp, Rs)
    b, a = signal.butter(N, Wn, 'low')
    y = signal.lfilter(b, a, data)
    return y

def butter_highpass(data, pass_freq, stop_freq, Rp = 0.5, Rs = 40, fs = 1000):
    Wp = pass_freq / (fs / 2)
    Ws = stop_freq / (fs / 2)

    N, Wn = signal.buttord(Wp, Ws, Rp, Rs)
    b, a = signal.butter(N, Wn, 'high')
    y = signal.lfilter(b, a, data)
    return y

def main():
    fs = 1000.0
    low_pass_freq = 80
    low_stop_freq = 95
    low_Rp = 3
    low_Rs = 30

    high_pass_freq = 10
    high_stop_freq = 5
    high_Rp = 0.5
    high_Rs = 40
    
    
    address = ('0.0.0.0', 8887)  
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # s = socket.socket()  
    s.bind(address)  
    s.listen(1)
    ss, addr = s.accept()  
    print('got connected from',addr)

    count = 0
    step_length = 4000
    csi_list = []
    t = np.linspace(0, step_length, step_length, endpoint=True)
    
    start_time = time.time()
    while(True):
        ra = ss.recv(4096)  
        # print(ra)
        if ra != b'':
            if ra[0] == 187:
                csi = read_bfee(ra[1:])
                csi_list.append(csi.csi)
                count += 1
        else:
            break
        if count == step_length:
            end_time = time.time()
            print(step_length / (end_time - start_time))
            start_time = time.time()
            count = 0
            csi_np_array = np.array(csi_list)
            csi_list = []
            csi_stream = np.absolute(csi_np_array[:,:,0,0])
            csi_stream = csi_stream.transpose(1,0)
            print(csi_stream.shape)
            #plot_signal(b, a, csi_np_array)
            plot_signal(csi_stream, fs, low_pass_freq, low_stop_freq, low_Rp, low_Rs,
                    high_pass_freq, high_stop_freq, high_Rp, high_Rs,t)
            print("plot finish")
            #break
    ss.close()  
    s.close()  

if __name__ == '__main__':
    main()
\end{lstlisting}
\section{数据预处理}
\subsection{Numpy的应用}
在后续的代码处理中主要使用了一下Numpy包中的函数，在此列举以方便查看
\begin{lstlisting}[language=Python]
np.logspace
np.abs
np.absolute
np.multiply
np.sqrt
np.power
np.zeros
np.squeeze
np.dot
np.transpose
np.conj
np.real
np.imag
np.sum
np.linalg.inv
np.eye
np.diag
np.spacing
np.min
np.mean
np.ndarray
np.square
\end{lstlisting}
\subsection{代码部分}
\subsubsection{信号处理基础函数实现}
\begin{lstlisting}[language=Python, caption=bpsk.py]
    # -*- coding: UTF-8 -*-
    # Binary Phase Shift Keying
    import numpy as np
    from scipy.stats import norm
    
    
    def bpsk_ber(snr):
        ret = norm.sf(np.sqrt(2 * snr))
        return ret
    
    
    def bpsk_berinv(ber):
        ret = np.square(norm.isf(ber)) / 2
        return ret    
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=qam.py]
    # -*- coding: UTF-8 -*-

    # Quadrature Amplitude Modulation
    
    import numpy as np
    from scipy.stats import norm
    
    
    def qam16_ber(snr):
        ret = 3/4 * norm.sf(np.sqrt(snr/5))
        return ret
    
    
    def qam16_berinv(ber):
        ret = np.square(norm.isf(ber * 4/3)) * 5
        return ret
    
    
    def qam64_ber(snr):
        ret = 7/12 * norm.sf(np.sqrt(snr/21))
        return ret
    
    
    def qam64_berinv(ber):
        ret = np.square(norm.isf(ber * 12/7)) * 21
        return ret
    
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=qpsk.py]
    # -*- coding: UTF-8 -*-

    # Quadrature Phase Shift Keyin
    
    import numpy as np
    from scipy.stats import norm
    
    def qpsk_ber(snr):
        ret = norm.sf(np.sqrt(snr))
        return ret
    
    def qpsk_berinv(ber):
        ret = np.square(norm.isf(ber))
        return ret
\end{lstlisting}
\subsubsection{CSI信息提取}
\begin{lstlisting}[language=Python, caption=$ get\_scaled\_csi.py $]
    import numpy as np
    from math import log10,pi,exp
    
    class SmMatrices:
        def __init__(self):
            self.SM_1 = 1
            self.SM_2_20 = [[1 , 1] , [1 , -1]] / np.sqrt(2)
            self.SM_2_40 = [[1 , 1j] , [1j , 1]] / np.sqrt(2)
            self.SM_3_20 = [[-2*pi/16 , -2*pi/(80/33) , 2*pi/(80/3)],[2*pi/(80/23) , 2*pi/(48/13) , 2*pi/(240/13)],[-2*pi/(80/13) , 2*pi/(240/37) , 2*pi/(48/13)]]
            self.SM_3_20 = np.power(exp(1),(np.multiply([1j] , self.SM_3_20))).tolist() / np.sqrt(3)
            self.SM_3_40 = [[-2*pi/16 , -2*pi/(80/13) , 2*pi/(80/23)],[-2*pi/(80/37) , -2*pi/(48/11) , -2*pi/(240/107)],[2*pi/(80/7) , -2*pi/(240/83) , -2*pi/(48/11)]]
            self.SM_3_40 = np.power(exp(1),(np.multiply([1j] , self.SM_3_40))).tolist() / np.sqrt(3)
    
    def dbinv(x):
        ret = pow(10,( x / 10))
        return ret
    
    def db(x):
        ret = 10 * log10(x) + 300 -300
        return ret
    
    def get_total_rss(csi_st):
        rssi_mag = 0
        if int(csi_st.rssi_a) != 0:
            rssi_mag = rssi_mag + dbinv(int(csi_st.rssi_a))
        if int(csi_st.rssi_b) != 0:
            rssi_mag = rssi_mag + dbinv(int(csi_st.rssi_b))
        if int(csi_st.rssi_c) != 0:
            rssi_mag = rssi_mag + dbinv(int(csi_st.rssi_c))  
        print(rssi_mag)
        ret = db(rssi_mag) - 44 - csi_st.agc
        return ret
    
    def remove_sm(csi, rate):
        csi_size = csi.shape
        if csi_size[1] == 1:
            ret = csi
    
        ret = np.zeros(csi_size)
        ret_real = np.zeros(csi_size)
        ret_i = np.zeros(csi_size)
        const_sm = SmMatrices()
        if (rate & 2048) == 2048:
            if csi_size[1] == 3:
                sm = const_sm.SM_3_40
            elif csi_size[1] == 2:
                sm = const_sm.SM_2_40
        else:
            if csi_size[1] == 3:
                sm = const_sm.SM_3_20
            elif csi_size[1] == 2:
                sm = const_sm.SM_2_20
        for i in range(csi_size[0]):
            t = np.squeeze(csi[i])
            H = np.dot(np.transpose(t),np.conj(np.transpose(sm)))
            ret_real[i] = np.transpose(np.real(H))
            ret_i[i] = np.transpose(np.imag(H))
        ret = ret_real + np.multiply([1j] , ret_i)
        return ret
        
    def get_scaled_csi(csi_st):
        csi = csi_st.csi
    
        csi_sq = np.multiply(csi,np.conj(csi))
        csi_pwr = np.sum(csi_sq)
        rssi_pwr = dbinv(get_total_rss(csi_st))
        scale = rssi_pwr / (csi_pwr / 30)
        if csi_st.noise == -127:
            noise_db = -92
        else:
            noise_db = csi_st.noise
        thermal_noise_pwr = dbinv(noise_db)
        quant_error_pwr = scale * (csi_st.Nrx * csi_st.Ntx)
        total_noise_pwr = thermal_noise_pwr + quant_error_pwr
        ret = csi * np.sqrt(scale / total_noise_pwr)
    
        if csi_st.Ntx == 2:
            ret = ret * np.sqrt(2)
        elif csi_st.Ntx == 3:
            ret = ret * np.sqrt(dbinv(4.5))
        
        return ret
    
    def get_scaled_csi_sm(csi_st):
        ret = get_scaled_csi(csi_st)
        ret = remove_sm(ret,csi_st.rate)
        return ret
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=$ get\_SNRs.py $]
    import numpy as np
    from signal_proc.bpsk import *
    from signal_proc.qpsk import *
    from signal_proc.qam import *
    import sys
    from math import pi,exp
    
    class SmMatrices:
        def __init__(self):
            self.SM_1 = 1
            self.SM_2_20 = [[1 , 1] , [1 , -1]] / np.sqrt(2)
            self.SM_2_40 = [[1 , 1j] , [1j , 1]] / np.sqrt(2)
            self.SM_3_20 = [[-2*pi/16 , -2*pi/(80/33) , 2*pi/(80/3)],[2*pi/(80/23) , 2*pi/(48/13) , 2*pi/(240/13)],[-2*pi/(80/13) , 2*pi/(240/37) , 2*pi/(48/13)]]
            self.SM_3_20 = np.power(exp(1),(np.multiply([1j] , self.SM_3_20))).tolist() / np.sqrt(3)
            self.SM_3_40 = [[-2*pi/16 , -2*pi/(80/13) , 2*pi/(80/23)],[-2*pi/(80/37) , -2*pi/(48/11) , -2*pi/(240/107)],[2*pi/(80/7) , -2*pi/(240/83) , -2*pi/(48/11)]]
            self.SM_3_40 = np.power(exp(1),(np.multiply([1j] , self.SM_3_40))).tolist() / np.sqrt(3)
    
    def dbinv(x):
        ret = pow(10,(x/10))
        return ret
    
    def apply_sm(csi,sm):
        csi_size = csi.shape
        if csi_size[1] == 1:
            ret = csi
        if len(csi_size) == 2:
            ret = np.zeros(csi_size)
            t = np.squeeze(csi)
            ret = np.transpose(np.dot(np.transpose(t) , sm))
        else:
            ret = np.zeros(csi_size)
            for i in range(csi_size[0]):
                t = np.squeeze(csi[i])
                ret[i] = np.transpose(np.dot(np.transpose(t) , sm))        
        return ret
    
    def mimo3_mmse(csi):
        M = np.linalg.inv(np.dot(np.conj(csi),np.transpose(csi)) + np.eye(3))
        ret = 1 / np.diag(M) - 1
        ret = np.real(ret)
        return ret
    
    def get_mimo3_SNRs(csi):
        csi_size = csi.shape  # [S M N]
        if csi_size[1] < 3 or csi_size[2] < 3:
            sys.exit("CSI matrix must have at least 3 TX antennas and 3 RX antennas")
        csi = csi / np.sqrt(dbinv(4.5))
    
        ret = np.zeros((csi_size[0],1,3))
        for i in range(csi_size[0]):
            ret[i][0] = mimo3_mmse(np.squeeze(csi[i]))
        return ret
    
    def mimo3_mmse_sm(csi_i):
        const_sm = SmMatrices()
        csi = apply_sm(csi_i,const_sm.SM_3_20)
        M = np.linalg.inv(np.dot(np.conj(csi),np.transpose(csi)) + np.eye(3))
        ret = 1 / np.diag(M) - 1
        ret = np.real(ret)
        return ret
    
    def get_mimo3_SNRs_sm(csi):
        csi_size = csi.shape  # [S M N]
        if csi_size[1] < 3 or csi_size[2] < 3:
            sys.exit("CSI matrix must have at least 3 TX antennas and 3 RX antennas")
        csi = csi / np.sqrt(dbinv(4.5))
    
        ret = np.zeros((csi_size[0],1,3))
        for i in range(csi_size[0]):
            ret[i][0] = mimo3_mmse_sm(np.squeeze(csi[i]))
        return ret
    
    def mimo2_mmse(csi):
        M = np.linalg.inv(np.dot(np.conj(csi),np.transpose(csi)) + np.eye(2))
        ret = 1 / np.diag(M) - 1
        ret = np.real(ret)
        return ret
    
    def get_mimo2_SNRs(csi):
        csi_size = csi.shape  # [S M N]
        if csi_size[1] < 2 or csi_size[2] < 2:
            sys.exit("CSI matrix must have at least 2 TX antennas and 2 RX antennas")
        csi = csi / np.sqrt(2)
        if csi_size[1] == 2:
            ret = np.zeros((csi_size[0],1,2))
            for i in range(csi_size[0]):
                ret[i][0] = mimo2_mmse(np.squeeze(csi[i]))
        else:
            ret = np.zeros((csi_size[0],3,2))
            for i in range(csi_size[0]):
                ret[i][0] = mimo2_mmse(np.squeeze(csi[i][[0,1]]))
                ret[i][1] = mimo2_mmse(np.squeeze(csi[i][[0,2]]))
                ret[i][2] = mimo2_mmse(np.squeeze(csi[i][[1,2]]))
        return ret
    
    def mimo2_mmse_sm(csi_i):
        const_sm = SmMatrices()
        csi = apply_sm(csi_i,const_sm.SM_2_20)
        M = np.linalg.inv(np.dot(np.conj(csi),np.transpose(csi)) + np.eye(2))
        ret = 1 / np.diag(M) - 1
        ret = np.real(ret)
        return ret
    
    def get_mimo2_SNRs_sm(csi):
        csi_size = csi.shape  # [S M N]
        if csi_size[1] < 2 or csi_size[2] < 2:
            sys.exit("CSI matrix must have at least 2 TX antennas and 2 RX antennas")
        csi = csi / np.sqrt(2)
        if csi_size[1] == 2:
            ret = np.zeros((csi_size[0],1,2))
            for i in range(csi_size[0]):
                ret[i][0] = mimo2_mmse_sm(np.squeeze(csi[i]))
        else:
            ret = np.zeros((csi_size[0],3,2))
            for i in range(csi_size[0]):
                ret[i][0] = mimo2_mmse_sm(np.squeeze(csi[i][[0,1]]))
                ret[i][1] = mimo2_mmse_sm(np.squeeze(csi[i][[0,2]]))
                ret[i][2] = mimo2_mmse_sm(np.squeeze(csi[i][[1,2]]))
        return ret
    
    def get_simo_SNRs(csi):
        ret = []
        for i in np.multiply(csi,np.conj(csi)):
            ret.append(np.sum(i,axis=1,keepdims=2))
        ret = np.real(ret)
        return ret
    
    def get_eff_SNRs(csi):
        ret = np.zeros((7,4)) + np.spacing(1)
        csi_size = csi.shape
    
        k = np.min(csi_size[1:])
        if k>=1:
            snrs = get_simo_SNRs(csi)
    
            bers = bpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0:len(mean_ber),0] = bpsk_berinv(mean_ber)
    
            bers = qpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0:len(mean_ber),1] = qpsk_berinv(mean_ber)
    
            bers = qam16_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0:len(mean_ber),2] = qam16_berinv(mean_ber)
    
            bers = qam64_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0:len(mean_ber),3] = qam64_berinv(mean_ber)
    
        
        if k >= 2:
            snrs = get_mimo2_SNRs(csi)
    
            bers = bpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 3:len(mean_ber) + 3,0] = bpsk_berinv(mean_ber)
    
            bers = qpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 3:len(mean_ber) + 3,1] = qpsk_berinv(mean_ber)
    
            bers = qam16_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 3:len(mean_ber) + 3,2] = qam16_berinv(mean_ber)
    
            bers = qam64_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 3:len(mean_ber) + 3,3] = qam64_berinv(mean_ber)
    
    
        if k >= 3:
            snrs = get_mimo3_SNRs(csi)
    
            bers = bpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 6:len(mean_ber) + 6,0] = bpsk_berinv(mean_ber)
    
            bers = qpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 6:len(mean_ber) + 6,1] = qpsk_berinv(mean_ber)
    
            bers = qam16_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 6:len(mean_ber) + 6,2] = qam16_berinv(mean_ber)
    
            bers = qam64_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 6:len(mean_ber) + 6,3] = qam64_berinv(mean_ber)
    
        return ret
    
    def get_eff_SNRs_sm(csi):
        ret = np.zeros((7,4)) + np.spacing(1)
        csi_size = csi.shape
    
        k = np.min(csi_size[1:])
        if k>=1:
            snrs = get_simo_SNRs(csi)
    
            bers = bpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0:len(mean_ber),0] = bpsk_berinv(mean_ber)
    
            bers = qpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0:len(mean_ber),1] = qpsk_berinv(mean_ber)
    
            bers = qam16_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0:len(mean_ber),2] = qam16_berinv(mean_ber)
    
            bers = qam64_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0:len(mean_ber),3] = qam64_berinv(mean_ber)
    
        
        if k >= 2:
            snrs = get_mimo2_SNRs_sm(csi)
    
            bers = bpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 3:len(mean_ber) + 3,0] = bpsk_berinv(mean_ber)
    
            bers = qpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 3:len(mean_ber) + 3,1] = qpsk_berinv(mean_ber)
    
            bers = qam16_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 3:len(mean_ber) + 3,2] = qam16_berinv(mean_ber)
    
            bers = qam64_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 3:len(mean_ber) + 3,3] = qam64_berinv(mean_ber)
    
    
        if k >= 3:
            snrs = get_mimo3_SNRs_sm(csi)
    
            bers = bpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 6:len(mean_ber) + 6,0] = bpsk_berinv(mean_ber)
    
            bers = qpsk_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 6:len(mean_ber) + 6,1] = qpsk_berinv(mean_ber)
    
            bers = qam16_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 6:len(mean_ber) + 6,2] = qam16_berinv(mean_ber)
    
            bers = qam64_ber(snrs)
            mean_ber = np.mean(np.mean(bers,axis=0),axis=1)
            ret[0 + 6:len(mean_ber) + 6,3] = qam64_berinv(mean_ber)
    
        return ret
\end{lstlisting}

\section{模型建立与训练}

\section{模型评估}
原始数据使用1:9分割测试集和训练集，实验结果使用混淆矩阵进行评估
\subsection{核心代码}
\begin{lstlisting}[language=Python, caption=$ get\_SNRs.py $]
\end{lstlisting}
\end{document}